#input: a 2D array of 1 and 0 where 0 is walkable and 1 is not, tuple of start and end locations, and path if there is one
#output: a list of tuples indicating target tiles

def findShortestPath(app,maze,startLocation,targetLocation,path = []):
    if isRightNextToEachOther(startLocation,targetLocation):
        return path
    else:
        #create neighbors
        row,col = startLocation
        neighbors = [(startLocation[0] + 1,startLocation[1]),(startLocation[0] - 1,startLocation[1]),
                     (startLocation[0],startLocation[1] + 1,(startLocation[0],startLocation[1] - 1))]
        
        #check if neighbor already in path
        for tile in neighbors:
            if tile in path:
                neighbors.remove(tile)

        sortedNeighbors = sortByBestGuess(neighbors)

        #tile is a tuple of the row and col of the tile
        for tile in sortedNeighbors:
            if isLegalMove(maze,tile):
                path.append(tile)
                solution = findShortestPath(app,maze,tile,targetLocation,path)
                if solution != None:
                    return solution
                else:
                    path.pop(-1)
        return None

def sortByBestGuess(neighbors):

def isLegalMove(maze,targetTile):
    row,col = targetTile
    if maze[row][col] == 1:
        return False
    else:
        return True

def isRightNextToEachOther(start,end):
    if start[0] - end[0] == 0 and abs(start[1] - end[1]) == 1:
        return True
    elif start[1] - end[1] == 0 and abs(start[0] - end[0]) == 1:
        return True
    else:
        return False
